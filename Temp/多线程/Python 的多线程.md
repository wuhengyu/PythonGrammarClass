### Python 的多线程

- Python中的多线程是假的多线程
- 全局解释器锁（GIL）
    - Python代码的执行由Python虚拟机（解释器）来控制
    - Python解释器可以运行多个线程，只有一个线程在解释器中运行
    - 通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器
    - 对Python虚拟机的访问由全局解释器锁（GIL）来控制
        - 任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行
        - 这个GIL全局锁实际上把所有线程的执行代码都给上了锁，所以，多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核
    - 在多线程环境中，Python虚拟机按照以下方式执行
        - 1.设置GIL(global interpreter lock)
        - 2.切换到一个线程执行
        - 3.运行：指定数量的字节码指令、线程主动让出控制（可以调用time.sleep(0)）
        - 4.把线程设置为睡眠状态
        - 5.解锁GIL
        - 6.再次重复以上步骤。
    - 对所有面向I/O的（会调用内建的操作系统C代码的）程序来说，GIL会在这个I/O调用之前被释放，以允许其他线程在这个线程等待I/O的时候运行
    - 如果某线程并未使用很多I/O操作，它会在自己的时间片内一直占用处理器和GIL
    - I/O密集型的Python程序比计算密集型的Python程序更能充分利用多线程的好处
    - Python不不管你有几个核，单位时间多个核只能跑一个线程，然后时间片轮转
    - 任何Python线程执行前，必须先获得GIL锁，然后，每执行100条字节码，解释器就自动释放GIL锁，让别的线程有机会执行
    - 多线程在Python中只能交替执行，即使100个线程跑在100核CPU上，也只能用到1个核
    - 通常我们用的解释器是官方实现的CPython，要真正利用多核，除非重写一个不带GIL的解释器
- Python中利用多核解决方案
    - 多进程
    - 调用C语言的链接库
        - 对所有面向I/O密集型的（会调用内建的操作系统C代码的）程序来说，GIL会在这个I/O调用之前被释放，以允许其他线程在这个线程等待I/O的时候运行
        - 计算密集型任务用C语言编写，然后把.so链接库内容加载到Python中，因为执行C代码，GIL锁会释放，这样一来，就可以做到每个核都跑一个线程的目的
- 计算密集型任务
    - 计算密集型任务的特点是要进行大量的计算，消耗CPU资源，比如计算圆周率、对视频进行高清解码等等，全靠CPU的运算能力
    - 计算密集型任务由于主要消耗CPU资源，因此，代码运行效率至关重要。Python这样的脚本语言运行效率很低，完全不适合计算密集型任务。对于计算密集型任务，最好用C语言编写
- I/O密集型任务
    - IO密集型，涉及到网络、磁盘IO的任务都是IO密集型任务，这类任务的特点是CPU消耗很少，任务的大部分时间都在等待IO操作完成（因为IO的速度远远低于CPU和内存的速度）
    - IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率
    - 对于IO密集型任务，任务越多，CPU效率越高，但也有一个限度。常见的大部分任务都是IO密集型任务，比如Web应用
    - IO密集型任务执行期间，99%的时间都花在IO上，花在CPU上的时间很少，因此，用运行速度极快的C语言替换用Python这样运行速度极低的脚本语言，完全无法提升运行效率
    - 对于IO密集型任务，最合适的语言就是开发效率最高（代码量最少）的语言，脚本语言是首选，C语言最差
    - Python多线程等于单核多线程，一般多线程有两个好处：CPU并行，IO并行，Python多线程(单核多线程)相当于自断一臂
- python虚拟机机制控制代码执行
    - 对于python来说，作为解释型语言，Python的解释器必须做到既安全又高效,避免在不同的线程操作内部共享的数据，同时它还要保证在管理用户线程时保证总是有最大化的计算资源
    - python是通过使用全局解释器锁来保护数据的安全性
    - python 代码的执行由python虚拟机来控制，即Python先把代码（.py文件）编译成字节码（字节码在Python虚拟机程序里对应的是
      PyCodeObject对象，.pyc文件是字节码在磁盘上的表现形式），交给字节码虚拟机，然后虚拟机一条一条执行字节码指令，从而完成程序的执行
    - python在设计的时候在虚拟机中，同时只能有一个线程执行
    - 虽然python解释器中可以运行多个线程，但在任意时刻，只有一个线程在解释器
      中运行。而对python虚拟机的访问由全局解释器锁来控制，正是这个锁能保证同一时刻只有一个线程在运行。
    - 对面向I/O的（会调用内建操作系统C代码的）程序来说，GIL会在这个I/O调用之前被释放，以允许其他线程在这个线程等待I/O的时候运行。如果线程
      并未使用很多I/O操作，它会在自己的时间片一直占用处理器和GIL
    - 想让python计算速度快起来，又不想写C，用pypy
    - 可以使用协程来提高cpu的利用率，使用multiprocessing和gevent
    - multiprocessing开销比较大，原因就在于：主进程和子进程之间通信，必须进行序列化和反序列化的操作
    - 默认主线程会等待所有子线程结束之后才会结束，主线程结束意味着程序退出；如果setDaemon设置为True,主线程则不会等待子线程，主线程结束，子线程自动结束
    - 原来主线程和子线程是并行的关系，但是一旦使用了join()方法，就会变成串行的关系；当主线程调用子线程的join()
      方法时，意味着必须等子线程执行完毕之后，主线程才会开始执行。
    - threading模块除了以上常用函数，还有互斥锁Lock/事件Event/信号量Condition/队列Queue等
- Python 的 Queue 模块中提供了同步的、线程安全的队列类，包括FIFO（先入先出)队列Queue，LIFO（后入先出）队列LifoQueue，和优先级队列
  PriorityQueue。
    - 这些队列都实现了锁原语，能够在多线程中直接使用，可以使用队列来实现线程间的同步。
    - Queue 模块中的常用方法:
        - Queue.qsize() 返回队列的大小
        - Queue.empty() 如果队列为空，返回True,反之False
        - Queue.full() 如果队列满了，返回True,反之False
        - Queue.full 与 maxsize 大小对应
        - Queue.get([block[, timeout]])获取队列，timeout等待时间
        - Queue.get_nowait() 相当Queue.get(False)
        - Queue.put(item) 写入队列，timeout等待时间
        - Queue.put_nowait(item) 相当Queue.put(item, False)
        - Queue.task_done() 在完成一项工作之后，Queue.task_done()函数向任务已经完成的队列发送一个信号
        - Queue.join() 实际上意味着等到队列为空，再执行别的操作
    
    
    